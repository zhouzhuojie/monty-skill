#!/bin/bash
# monty - Run Python in secure sandbox
# Usage: uv run monty "code" [OPTIONS]

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
FUNCTIONS_FILE="${SCRIPT_DIR}/functions.py"
TIMEOUT=30
CODE=""

# Parse arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        -h|--help)
            echo "Usage: uv run monty \"code\" [OPTIONS]"
            echo ""
            echo "Options:"
            echo "  -f, --functions FILE    Functions file (default: ./functions.py)"
            echo "  -t, --timeout SECONDS   Timeout (default: 30)"
            exit 0
            ;;
        -f|--functions)
            FUNCTIONS_FILE="$2"
            shift 2
            ;;
        -t|--timeout)
            TIMEOUT="$2"
            shift 2
            ;;
        *)
            CODE="$1"
            shift
            ;;
    esac
done

[[ -z "$CODE" ]] && { echo "Error: code required"; exit 1; }

# Find Python
PYTHON="${SCRIPT_DIR}/.venv/bin/python"
[[ -f "$PYTHON" ]] || PYTHON="python3"

# Check monty
"$PYTHON" -c "import pydantic_monty" 2>/dev/null || { echo "Error: pydantic-monty not installed"; echo "Install: uv add pydantic-monty"; exit 1; }

# Temp files
TEMP_SCRIPT=$(mktemp /tmp/monty_XXXXXX.py)
TEMP_CODE=$(mktemp /tmp/monty_code_XXXXXX.py)
trap "rm -f $TEMP_SCRIPT $TEMP_CODE" EXIT

echo "$CODE" > "$TEMP_CODE"

cat > "$TEMP_SCRIPT" << 'PYTHON'
import asyncio, sys
from pathlib import Path
import pydantic_monty

CODE_PATH, FNS_PATH = "CODE_PATH_PLACEHOLDER", "FNS_PATH_PLACEHOLDER"
with open(CODE_PATH) as f: code = f.read().strip()

funcs_code = ""
if Path(FNS_PATH).exists():
    with open(FNS_PATH) as f: funcs_code = f.read()

import re
fn_names = set()
for m in re.finditer(r'\b([a-zA-Z_][a-zA-Z0-9_]*)\s*\(', code):
    fn = m.group(1)
    if fn not in {'print','len','str','int','float','bool','list','dict','set','tuple',
                  'range','enumerate','zip','map','filter','sorted','reversed','type',
                  'isinstance','hasattr','getattr','setattr','delattr','break','continue',
                  'pass','return','yield','raise','try','except','finally','async','await',
                  'if','else','elif','for','while','def','class','import','from','as',
                  'assert','del','global','nonlocal','lambda','or','and','not','in',
                  'True','False','None','self','super'}:
        fn_names.add(fn)

external_fns = {}
if fn_names and funcs_code:
    ns = {}
    exec(compile(funcs_code, '<functions>', 'exec'), ns)
    for name in fn_names:
        if name in ns and callable(ns[name]):
            external_fns[name] = ns[name]

async def run():
    try:
        m = pydantic_monty.Monty(code, inputs=[], external_functions=list(external_fns.keys()),
                                script_name='sandbox.py', type_check=False, type_check_stubs=funcs_code)
        if external_fns:
            r = await pydantic_monty.run_monty_async(m, external_functions=external_fns)
        else:
            r = await pydantic_monty.run_monty_async(m)
        if r and hasattr(r, 'output'):
            print(r.output)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)

asyncio.run(run())
PYTHON

# Replace placeholders safely using Python
"$PYTHON" - "$TEMP_SCRIPT" "$TEMP_CODE" "$FUNCTIONS_FILE" << 'PY'
import sys
script_path = sys.argv[1]
code_path = sys.argv[2]
fns_path = sys.argv[3]

with open(script_path) as f:
    content = f.read()

content = content.replace('CODE_PATH_PLACEHOLDER', code_path)
content = content.replace('FNS_PATH_PLACEHOLDER', fns_path)

with open(script_path, 'w') as f:
    f.write(content)
PY

# Run with timeout
if command -v timeout &>/dev/null; then
    timeout "$TIMEOUT" "$PYTHON" "$TEMP_SCRIPT"
else
    "$PYTHON" "$TEMP_SCRIPT"
fi
